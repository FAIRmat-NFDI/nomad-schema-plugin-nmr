from typing import TYPE_CHECKING

import numpy as np

if TYPE_CHECKING:
    from nomad.datamodel.datamodel import EntryArchive
    from nomad.metainfo import Context, Section
    from structlog.stdlib import BoundLogger

from nomad.datamodel.metainfo.basesections import Entity
from nomad.metainfo import Quantity, SchemaPackage, Section, SubSection
from nomad_simulations.schema_packages.atoms_state import AtomsState
from nomad_simulations.schema_packages.outputs import Outputs as BaseOutputs
from nomad_simulations.schema_packages.physical_property import PhysicalProperty

m_package = SchemaPackage()


def resolve_name_from_entity_ref(entities: list[Entity], logger: "BoundLogger") -> str:
    """
    Resolves the `name` of the atom-resolved `PhysicalProperty` from the `entity_ref`
    by assigning a label corresponding to the `AtomsState.chemical_symbol` and a number
    corresponding to the position in the list of `AtomsState`.

    Args:
        entities (list[Entity]): The list of entities to resolve the name from.
        logger ('BoundLogger'): The logger to log messages.

    Returns:
        (str): The resolved name of the atom-resolved `PhysicalProperty`.
    """
    name = ""
    for entity in entities:
        atoms_state = entity
        # Check if `entity_ref` exists and it is an AtomsState
        if not atoms_state or not isinstance(atoms_state, AtomsState):
            logger.error(
                "Could not find `entity_ref` referencing an `AtomsState` section."
            )
            return ""
        # Check if the parent of `entity_ref` exists
        cell = atoms_state.m_parent
        if not cell:
            logger.warning(
                "The parent of the `AtomsState` in `entity_ref` does not exist."
            )
            return ""

        index = ""  # ! implement here if needed
        name += f"{atoms_state.chemical_symbol}{index}"
    return name


class MagneticShielding(PhysicalProperty):
    """
    Nuclear response of a material to shield the effects of an applied external field.
    This is a tensor 3x3 related with the induced magnetic field as:

        B_induced = - magnetic_shielding * B_external

    See, e.g, https://pubs.acs.org/doi/10.1021/cr300108a.

    This property will appear as a list under `Outputs` where each of the elements
    correspond to an atom in the unit cell.
    The specific atom is known by defining the reference to the specific `AtomsState`
    under `ModelSystem.cell.atoms_state` using `entity_ref`.
    """

    value = Quantity(
        type=np.float64,
        shape=[3, 3],
        unit="dimensionless",
        description="""
        Value of the magnetic shielding tensor per atom.
        """,
    )
    value_isotropic = Quantity(
        type=np.float64,
        unit="dimensionless",
        description="""
            The isotropic part of the `MagneticShieldingTensor`. This is 1/3 of the
            trace of the magnetic shielding tensor (see `extract_isotropic_part()`
            function in `MagneticShieldingTensor`).

            See, e.g, https://pubs.acs.org/doi/10.1021/cr300108a.
        """,
    )

    def __init__(
        self, m_def: "Section" = None, m_context: "Context" = None, **kwargs
    ) -> None:
        super().__init__(m_def, m_context, **kwargs)
        # ! this info is in the shape attribute of the Quantity
        self.rank = [3, 3]
        self.name = self.m_def.name

    def extract_isotropic_part(self, logger: "BoundLogger") -> float | None:
        """
        Extract the isotropic part of the magnetic shielding tensor. This is 1/3 of the
        trace of the magnetic shielding tensor `value`.

        Args:
            logger ('BoundLogger'): The logger to log messages.

        Returns:
            (Optional[float]): The isotropic part of the magnetic shielding tensor.
        """
        try:
            # Calculate the isotropic value
            isotropic = np.trace(np.array(self.value)) / 3.0
        except Exception:
            logger.warning("Could not extract the trace of the `value` tensor.")
            return None
        return isotropic

    def normalize(self, archive: "EntryArchive", logger: "BoundLogger") -> None:
        super().normalize(archive, logger)

        # Resolve `name` to be from the `entity_ref`
        self.name = resolve_name_from_entity_ref(
            entities=[self.entity_ref], logger=logger
        )

        # isotropic value extraction
        isotropic = self.extract_isotropic_part(logger)
        if isotropic is not None:
            logger.info(f"Appending isotropic value for {self.name}")
            self.value_isotropic = isotropic
        else:
            logger.warning(f"Isotropic value extraction failed for {self.name}")


class ElectricFieldGradient(PhysicalProperty):
    """
    Interaction between the quadrupole moment of the nucleus and the electric field
    gradient (EFG) at the nucleus position generated by the surrounding charges.
    This property is relevant for Nuclear Magnetic Resonance (NMR). The eigenvalues
    of these tensors can be used to compute the `quadrupolar_coupling_constant` and
    the `asymmetry_parameter`.

    See, e.g, https://pubs.acs.org/doi/10.1021/cr300108a.

    This class by default refers to the 'total' contribution to the EFG. This property
    will appear as a list under `Outputs` where each of the elements correspond to an atom
    in the unit cell.
    The specific atom is known by defining the reference to the specific `AtomsState`
    under `ModelSystem.cell.atoms_state` using `entity_ref`.
    """

    # The below code is commented out because we want to capture the local and non-local
    # contributions to the EFG in their own classes.
    # type = Quantity(
    #     type=MEnum("total", "local", "non_local"),
    #     description="""
    #     Type of contribution to the electric field gradient (EFG). The total EFG can be
    #     decomposed on the `local` and `non_local` contributions.
    #     """,
    # )

    value = Quantity(
        type=np.float64,
        shape=[3, 3],
        unit="volt / meter ** 2",
        description="""
        The electric field gradient (EFG) tensor.
        """,
    )

    quadrupolar_coupling_constant = Quantity(
        type=np.float64,
        description="""
        Quadrupolar coupling constant for each atom in the unit cell.
        Once the eigenvalues of the EFG tensors are computed, it is computed as:

            quadrupolar_coupling_constant = efg_zz * e * Q / h

        where efg_zz is the largest eigenvalue of the EFG tensor,
        Q is the nuclear quadrupole moment, e is the elementary charge, and
        h is the Planck's constant.
        """,
    )

    asymmetry_parameter = Quantity(
        type=np.float64,
        description="""
        Asymmetry parameter for each atom in the unit cell. It is computed from the
        eigenvalues of the EFG tensor as:

            asymmetry_parameter = (efg_xx - efg_yy) / efg_zz

        where efg_xx, efg_yy and efg_zz are the eigenvalues of the EFG tensor ordered
        such that |efg_zz| > |efg_yy| > |efg_xx|.
        """,
    )

    def __init__(
        self, m_def: "Section" = None, m_context: "Context" = None, **kwargs
    ) -> None:
        super().__init__(m_def, m_context, **kwargs)
        self.rank = [3, 3]  # ! move this to definitions  !!! TODO
        self.name = self.m_def.name

    def resolve_quadrupolar_coupling_constant(self, logger: "BoundLogger") -> None:
        pass

    def resolve_asymmetry_parameter(self, logger: "BoundLogger") -> None:
        pass

    def normalize(self, archive: "EntryArchive", logger: "BoundLogger") -> None:
        super().normalize(archive, logger)

        # Resolve `name` to be from the `entity_ref`
        self.name = resolve_name_from_entity_ref(
            entities=[self.entity_ref], logger=logger
        )

        # TODO add normalization to extract `quadrupolar_coupling_constant`
        # and `asymmetry_parameter`


class ElectricFieldGradientLocal(PhysicalProperty):
    """
    Represents the local contribution to the electric field gradient (EFG) at the
    nucleus position. Some DFT codes may provide the EFG decomposed into theory-dependent
    contributions. The local contribution is one of these decomposed contributions,
    identified by a 'efg_local' tag in the magres data block of a .magres file.

    This property is relevant for Nuclear Magnetic Resonance (NMR) and will appear
    as a list under `Outputs` where each element corresponds to an atom in the unit cell.

    The specific atom is known by defining the reference to the specific `AtomsState`
    under `ModelSystem.cell.atoms_state` using `entity_ref`.
    """

    value = Quantity(
        type=np.float64,
        shape=[3, 3],
        unit="volt / meter ** 2",
        description="""
        Value of the local electric field gradient (EFG) tensor for each atom.
        """,
    )

    def __init__(
        self, m_def: "Section" = None, m_context: "Context" = None, **kwargs
    ) -> None:
        super().__init__(m_def, m_context, **kwargs)
        self.rank = [3, 3]  # ! move this to definitions  !!! TODO
        self.name = self.m_def.name

    def normalize(self, archive: "EntryArchive", logger: "BoundLogger") -> None:
        super().normalize(archive, logger)

        # Resolve `name` to be from the `entity_ref`
        self.name = resolve_name_from_entity_ref(
            entities=[self.entity_ref], logger=logger
        )


class ElectricFieldGradientNonlocal(PhysicalProperty):
    """
    Represents the non-local contribution to the electric field gradient (EFG) at the
    nucleus position. Some DFT codes may provide the EFG decomposed into theory-dependent
    contributions. The non-local contribution is one of these decomposed contributions,
    identified by a 'efg_nonlocal' tag in the magres data block of a .magres file.

    This property is relevant for Nuclear Magnetic Resonance (NMR) and will appear
    as a list under `Outputs` where each element corresponds to an atom in the unit cell.

    The specific atom is known by defining the reference to the specific `AtomsState`
    under `ModelSystem.cell.atoms_state` using `entity_ref`.
    """

    value = Quantity(
        type=np.float64,
        shape=[3, 3],
        unit="volt / meter ** 2",
        description="""
        Value of the non-local electric field gradient (EFG) tensor for each atom.
        """,
    )

    def __init__(
        self, m_def: "Section" = None, m_context: "Context" = None, **kwargs
    ) -> None:
        super().__init__(m_def, m_context, **kwargs)
        self.rank = [3, 3]  # ! move this to definitions  !!! TODO
        self.name = self.m_def.name

    def normalize(self, archive: "EntryArchive", logger: "BoundLogger") -> None:
        super().normalize(archive, logger)

        # Resolve `name` to be from the `entity_ref`
        self.name = resolve_name_from_entity_ref(
            entities=[self.entity_ref], logger=logger
        )


# class ElectricFieldGradients(BaseOutputs):
#     """
#     Represents the electric field gradients (EFG) data.

#     This class contains the total, local, and non-local components
#     of the electric field gradients.
#     Each component is represented as a subsection of the ElectricFieldGradient class
#     and can have multiple entries.

#     Attributes:
#         efg_total (SubSection): A list of total electric field gradient entries.
#         efg_local (SubSection): A list of local electric field gradient entries.
#         efg_nonlocal (SubSection): A list of non-local electric field gradient entries.
#     """

#     efg_total = SubSection(sub_section=ElectricFieldGradient.m_def, repeats=True)
#     efg_local = SubSection(sub_section=ElectricFieldGradient.m_def, repeats=True)
#     efg_nonlocal = SubSection(sub_section=ElectricFieldGradient.m_def, repeats=True)


class IndirectSpinSpinCoupling(PhysicalProperty):
    """
    Indirect exchanges or interactions between 2 nuclear spins that arises from
    hyperfine interactions between the nuclei and local electrons. This parameter is
        identified by the 'isc' tag in the magres data block of a .magres file.

    The total indirect coupling can be decomposed into the following contributions, which
    can each be output by some DFT codes:
        - Fermi contact (tag 'isc_fc' in the magres data block)
        - Orbital paramagnetic (tag 'isc_orbital_p' in the magres data block)
        - Orbital diamagnetic (tag 'isc_orbital_d' in the magres data block)
        - Spin dipolar (tag 'isc_spin' in the magres data block)
    These contributions will be captured in their own classes.

    This property will appear as a list under `Outputs` where each of the elements
    correspond to an atom-atom coupling term. The specific pair of atoms defined for
    the coupling is known by referencing the specific `AtomsState`
    under `ModelSystem.cell.atoms_state` using `entity_ref_1` and `entity_ref_2`.
    """

    # TODO dipolar (or direct) coupling needs to be included at a higher level,
    # potentially calculated by Soprano python library to compute the overall spin-spin
    # coupling.

    # we hide `entity_ref` from `PhysicalProperty` to avoid confusion
    m_def = Section(a_eln={"hide": ["entity_ref"]})

    # The below code is commented out because we want to capture the decomposed
    # contributions to the indirect spin-spin coupling in their own classes.
    # type = Quantity(
    #     type=MEnum(
    #         "total",
    #         "direct_dipolar",
    #         "fermi_contact",
    #         "orbital_diamagnetic",
    #         "orbital_paramagnetic",
    #         "spin_dipolar",
    #     ),
    #     description="""
    #     Type of contribution to the indirect spin-spin coupling. The total indirect
    #     spin-spin coupling is composed of:

    #         `total` = `direct_dipolar` + J_coupling

    #     Where the J_coupling is:
    #         J_coupling = `fermi_contact`
    #                     + `spin_dipolar`
    #                     + `orbital_diamagnetic`
    #                     + `orbital_paramagnetic`

    #     See https://pubs.acs.org/doi/full/10.1021/cr300108a.
    #     """,
    # )

    value = Quantity(
        type=np.float64,
        shape=[3, 3],
        unit="tesla ** 2 / joule",
        description="""
        The total indirect spin-spin coupling tensor output from DFT codes is called the
        reduced spin coupling tensor K_ij, where i and j are nuclei between which the
        coupling is computed. The K_ij tensor is obtained from the magnetic field induced
        at nucleus i due to the perturbative effect of the magnetic moment of nucleus
        j as:

            K_ij = B_induced_i / magnetic_moment_j

        where B_induced_i is the induced magnetic field at nucleus i.

        Where the indirect spin-spin coupling is:
            indirect_spin_spin_coupling = `fermi_contact`
                                         + `spin_dipolar`
                                         + `orbital_diamagnetic`
                                         + `orbital_paramagnetic`

        See, https://pubs.acs.org/doi/full/10.1021/cr300108a.
        """,
    )

    jcoupling_value = Quantity(
        type=np.float64,
        unit="hertz",
        shape=[3, 3],  # dynamical shape only works for `PhysicalProperty.value`
        description="""
        The J-coupling tensor J_ij is obtained from the indirect spin-spin coupling using:
        It relates with the normal value as:

            jcoupling_value = (value *
                                gyromagnetic_ratio_i *
                                gyromagnetic_ratio_j *
                                2 *
                                np.pi *
                                hbar)

        where i, j runs for each atom in the unit cell.

        See, e.g, https://pubs.acs.org/doi/10.1021/cr300108a.
        """,
    )

    entity_ref_1 = Quantity(
        type=Entity,
        description="""
        Reference to the first entity that the coupling refers to. In this case, this
        is the first `AtomsState` in the pair of atoms that the coupling refers to.
        """,
    )

    entity_ref_2 = Quantity(
        type=Entity,
        description="""
        Reference to the second entity that the coupling refers to. In this case, this
        is the second `AtomsState` in the pair of atoms that the coupling refers to.
        """,
    )

    def __init__(
        self, m_def: "Section" = None, m_context: "Context" = None, **kwargs
    ) -> None:
        super().__init__(m_def, m_context, **kwargs)
        self.rank = [3, 3]  # ! move this to definitions

    def resolve_jcoupling_value(self, logger: "BoundLogger") -> None:
        pass

    def normalize(self, archive: "EntryArchive", logger: "BoundLogger") -> None:
        super().normalize(archive, logger)

        # Resolve `name` to be from the `entity_ref`
        self.name = resolve_name_from_entity_ref(
            entities=[self.entity_ref_1, self.entity_ref_2], logger=logger
        )

        # TODO add normalization to extract `jcoupling_value` from `value`


class IndirectSpinSpinCouplingFermiContact(PhysicalProperty):
    """
    Represents the Fermi contact contribution to the indirect spin-spin coupling.
    This contribution is identified by the 'isc_fc' tag in the magres data block
    of a .magres file.

    This property will appear as a list under `Outputs` where each element corresponds
    to an atom-atom coupling term. The specific pair of atoms is known by referencing
    the specific `AtomsState` under `ModelSystem.cell.atoms_state` using `entity_ref_1`
    and `entity_ref_2`.
    """

    value = Quantity(
        type=np.float64,
        shape=[3, 3],
        unit="tesla ** 2 / joule",
        description="""
        Value of the Fermi contact contribution to the indirect spin-spin coupling tensor.
        """,
    )

    def __init__(
        self, m_def: "Section" = None, m_context: "Context" = None, **kwargs
    ) -> None:
        super().__init__(m_def, m_context, **kwargs)
        self.rank = [3, 3]  # ! move this to definitions
        self.name = self.m_def.name

    def normalize(self, archive: "EntryArchive", logger: "BoundLogger") -> None:
        super().normalize(archive, logger)

        # Resolve `name` to be from the `entity_ref`
        self.name = resolve_name_from_entity_ref(
            entities=[self.entity_ref_1, self.entity_ref_2], logger=logger
        )


class IndirectSpinSpinCouplingOrbitalDiamagnetic(PhysicalProperty):
    """
    Represents the orbital diamagnetic contribution to the indirect spin-spin coupling.
    This contribution is identified by the 'isc_orbital_d' tag in the magres data block
    of a .magres file.

    This property will appear as a list under `Outputs` where each element corresponds
    to an atom-atom coupling term. The specific pair of atoms is known by referencing
    the specific `AtomsState` under `ModelSystem.cell.atoms_state` using `entity_ref_1`
    and `entity_ref_2`.
    """

    value = Quantity(
        type=np.float64,
        shape=[3, 3],
        unit="tesla ** 2 / joule",
        description="""
        Value of the orbital diamagnetic contribution to the indirect spin-spin coupling tensor.
        """,
    )

    def __init__(
        self, m_def: "Section" = None, m_context: "Context" = None, **kwargs
    ) -> None:
        super().__init__(m_def, m_context, **kwargs)
        self.rank = [3, 3]  # ! move this to definitions
        self.name = self.m_def.name

    def normalize(self, archive: "EntryArchive", logger: "BoundLogger") -> None:
        super().normalize(archive, logger)
        self.name = resolve_name_from_entity_ref(
            entities=[self.entity_ref_1, self.entity_ref_2], logger=logger
        )


class IndirectSpinSpinCouplingOrbitalParamagnetic(PhysicalProperty):
    """
    Represents the orbital paramagnetic contribution to the indirect spin-spin coupling.
    This contribution is identified by the 'isc_orbital_p' tag in the magres data block
    of a .magres file.

    This property will appear as a list under `Outputs` where each element corresponds
    to an atom-atom coupling term. The specific pair of atoms is known by referencing
    the specific `AtomsState` under `ModelSystem.cell.atoms_state` using `entity_ref_1`
    and `entity_ref_2`.
    """

    value = Quantity(
        type=np.float64,
        shape=[3, 3],
        unit="tesla ** 2 / joule",
        description="""
        Value of the orbital paramagnetic contribution to the indirect spin-spin coupling tensor.
        """,
    )

    def __init__(
        self, m_def: "Section" = None, m_context: "Context" = None, **kwargs
    ) -> None:
        super().__init__(m_def, m_context, **kwargs)
        self.rank = [3, 3]  # ! move this to definitions
        self.name = self.m_def.name

    def normalize(self, archive: "EntryArchive", logger: "BoundLogger") -> None:
        super().normalize(archive, logger)
        self.name = resolve_name_from_entity_ref(
            entities=[self.entity_ref_1, self.entity_ref_2], logger=logger
        )


class IndirectSpinSpinCouplingSpinDipolar(PhysicalProperty):
    """
    Represents the spin dipolar contribution to the indirect spin-spin coupling.
    This contribution is identified by the 'isc_spin' tag in the magres data block
    of a .magres file.

    This property will appear as a list under `Outputs` where each element corresponds
    to an atom-atom coupling term. The specific pair of atoms is known by referencing
    the specific `AtomsState` under `ModelSystem.cell.atoms_state` using `entity_ref_1`
    and `entity_ref_2`.
    """

    value = Quantity(
        type=np.float64,
        shape=[3, 3],
        unit="tesla ** 2 / joule",
        description="""
        Value of the spin dipolar contribution to the indirect spin-spin coupling tensor.
        """,
    )

    def __init__(
        self, m_def: "Section" = None, m_context: "Context" = None, **kwargs
    ) -> None:
        super().__init__(m_def, m_context, **kwargs)
        self.rank = [3, 3]  # ! move this to definitions
        self.name = self.m_def.name

    def normalize(self, archive: "EntryArchive", logger: "BoundLogger") -> None:
        super().normalize(archive, logger)
        self.name = resolve_name_from_entity_ref(
            entities=[self.entity_ref_1, self.entity_ref_2], logger=logger
        )


class MagneticSusceptibility(PhysicalProperty):
    """
    Section containing the information of magnetic susceptibility tensor. Degree of
    magnetization of a material in the presence of a magnetic field.

    This tensor is identified by the 'sus' tag in the magres data block of a .magres file.
    """

    m_def = Section(validate=False)

    value = Quantity(
        type=np.float64,
        unit="10 ** -6 * cm ** 3 / mol",
        description="""
        Value of the macroscopic magnetic susceptibility tensor.
        """,
    )

    def __init__(
        self, m_def: "Section" = None, m_context: "Context" = None, **kwargs
    ) -> None:
        super().__init__(m_def, m_context, **kwargs)
        self.rank = [3, 3]  # ! move this to definitions

    def normalize(self, archive: "EntryArchive", logger: "BoundLogger") -> None:
        super().normalize(archive, logger)

        # Resolve `name` to be from the `entity_ref`
        self.name = resolve_name_from_entity_ref(
            entities=[self.entity_ref], logger=logger
        )


class Outputs(BaseOutputs):
    """
    The outputs of the principal metadata for NMR.
    """

    magnetic_shieldings = SubSection(sub_section=MagneticShielding.m_def, repeats=True)
    electric_field_gradients = SubSection(
        sub_section=ElectricFieldGradient.m_def, repeats=True
    )
    electric_field_gradients_local = SubSection(
        sub_section=ElectricFieldGradientLocal.m_def, repeats=True
    )
    electric_field_gradients_nonlocal = SubSection(
        sub_section=ElectricFieldGradientNonlocal.m_def, repeats=True
    )
    indirect_spin_spin_couplings = SubSection(
        sub_section=IndirectSpinSpinCoupling.m_def, repeats=True
    )
    indirect_spin_spin_couplings_fermi_contact = SubSection(
        sub_section=IndirectSpinSpinCouplingFermiContact.m_def, repeats=True
    )
    indirect_spin_spin_couplings_orbital_p = SubSection(
        sub_section=IndirectSpinSpinCouplingOrbitalParamagnetic.m_def, repeats=True
    )
    indirect_spin_spin_couplings_orbital_d = SubSection(
        sub_section=IndirectSpinSpinCouplingOrbitalDiamagnetic.m_def, repeats=True
    )
    indirect_spin_spin_couplings_spin_dipolar = SubSection(
        sub_section=IndirectSpinSpinCouplingSpinDipolar.m_def, repeats=True
    )
    magnetic_susceptibilities = SubSection(
        sub_section=MagneticSusceptibility.m_def, repeats=True
    )


m_package.__init_metainfo__()
